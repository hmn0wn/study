Последний вопрос(ы). А почему не использовали стандартный ввод вывод? Это демонстрация переопределения операций?
Не могу до конца понять что такое: ostream &show_properties(ostream &stream); 
ostream &computer::show_properties(ostream &stream) итд. Не могу нигде найти точной информации. Знаю лишь некоторые компоненты по отдельности, но не всё это в целом.
Похоже на процедуру вывода, но почему именно такая реализация тогда?
И это: void main(int argc, char *argv[])
{
if (argc == 2 && !strcmp(argv[1], "help")). Что вы здесь сравнили?
Наверное последнее, что интересует: что у вас под pragma и почему именно её использовали?
Для чего используются входные данные? Просто для демонстрации, т.е. никакого вывода нет, верно? Я непросто на разных компиляторах вижу немного разную работу, где-то ошибка, где-то успешно, потому и спрашиваю все нюансы. Лично для меня там есть не стандартные вещи, есть даже книга, в которой это находится на тех страницах, до которых ещё пилить и пилить, как говориться.
О pragma region понял, вопрос снят.
В целом как я понимаю данные берутся из конфига, распознаются, доставляются на сервер и сервер заполняется лэптопами и компами с их данными, так? 
А ещё не понимаю почему в консоли ничего не печатается.

***********************************************************************************
Я переопределил(доопределил, перегрузил) стандартный оператор символьного вывода в поток:
<<
она может выводить в любой поток, как сout, что есть поток консоли
так и в иной объект потока типа вывода, типа ostream.

суть в том, что мы доопрегелили в ней работу с пользовательским типом computer.
весь механизм перегрузки этого оператора заключается в том, что поля у всех классов у нас приватные, и прямой доступ туда получить мы не можем, но это может сделать функция show_properties, это изначальное архитектурное решение, оправдывающее появление этой функции.

так вот, при перегрузке оператора << необходимо в поток выводить значения поле, а поля закрыты.

поэтому мы должны получить все данные через show_properties, а оптимально это можно сделать, если передать в эту функцию экземпляр символьного потока, везде где нужно в этот поток произвести стандартный текстовый вывод, и уже после, в момент перегрузки этот поток вернуть.


по сути, мы стандартный вывод и используем:
cout << endl << serv;

вот тут мы оператору << передаем два объекта, поток cout и экземпляр класса server.

ostream &operator<<(ostream &stream, server serv){
	serv.print_all(stream);
	return stream;
}


ссылка &stream это аргумент, который при использовании принимает cout.
а далее мы этот самый cout, который теперь лежит в stream, передаем всем функциям show_properties, которые в своию очередь в него и выводят все.
************************************************************************************
И это: void main(int argc, char *argv[])
{
if (argc == 2 && !strcmp(argv[1], "help"))

майн это функция, которая принимает в качестве аргументов массив чаровых строк, в которую пишутся ключи что присутствовали при запуске программы из консоли, в нулевой ячейке по умолчанию хнанится путь и имя экзешника, в первой и последующих, ключи, например ключ help

это я про argv[]
argc это колличество этих самых аргументов, занятых ячеек, по умолчанию одна, иначе на одну больше, чем ключей.

************************************************************************************
входные данные используются для создания объектов, сервер, компьютеры, и их инициализации, то есть заполнения полей, поля же нужны, чтобы продемонстрировать отличия между собой элементов классовой иерархии и работу функции shpw_properties, которая в свою очередь есть ключевой элемент демонстрации динамического полиморфизма.

задача сугубо академического характера, практической ценности не несет, служит подробным примером работы с классами в с++, практически применимый пример требует значительного усложнения программы, что никак не способствует изучению классов, скорее наоборот.

************************************************************************************
файл input.txt должен лежать в одной директории с исполняемым файлом, экзешником.
программа реализована на компилляторе визуал студии.
в консоль вывод будет только при корректном вводе, корректном заполнении файла input.txt:
____________________________________________________________________________________
129.0.0.1 512 DVI 65324 1920 1080 86 4000 8192
5
pc
50 128 VGA 256 512 512 86 2000 1024
pc
40 128 IPS 156 612 512 86 4000 1024
pc
30 128 VGA 216 312 512 86 1000 1024
laptop
1 128 VGA 251 312 512 86 1000 1024
laptop
0 128 IPS 255 712 512 86 2000 1024
______________________________________________________________________________________


по такому образцу.
да, он и есть тот самый конфиг.
при запуске программы напрямую из IDE стандартным способом, вывода в любом случае не последует, так как IDE по умолчанию не добавляет ключей при запуске релиза или дебага.